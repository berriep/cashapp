WITH params AS (
  -- Vul hier de gewenste datum en IBAN in
  SELECT
    DATE '[CLOSINGDATE]'        AS target_date,               -- precieze datum
    ARRAY['[IBAN]']::text[] AS ibans           -- leeg = alle IBANs
),
range AS (
  -- Gebruik target_date als zowel start als end (één dag)
  SELECT
    (SELECT target_date FROM params) AS start_date,
    (SELECT target_date FROM params) AS end_date
),
rng AS (
  SELECT generate_series((SELECT start_date FROM range),
                         (SELECT end_date   FROM range),
                         '1 day')::date AS day
),
-- IBANs in scope: uit balances (er is altijd closingBooked)
ib_all AS (
  SELECT DISTINCT b.iban
  FROM bai_rabobank_balances b
  CROSS JOIN params p
  WHERE b.balance_type = 'closingBooked'
    AND b.reference_date BETWEEN (SELECT start_date FROM range) - INTERVAL '1 day' AND (SELECT end_date FROM range)
    AND (
      (SELECT cardinality(p.ibans)) = 0
      OR b.iban IN (SELECT unnest(p.ibans))
    )
),
-- Audit OK/MISSING per dag/IBAN (uit audit_log)
audit_pivot AS (
  SELECT
    l.closingdate::date AS day,
    l.iban,
    CASE WHEN bool_or(l.response_status = 200) FILTER (WHERE l.endpoint = 'balances')     THEN 'OK' ELSE 'MISSING' END AS balances_status,
    CASE WHEN bool_or(l.response_status = 200) FILTER (WHERE l.endpoint = 'transactions') THEN 'OK' ELSE 'MISSING' END AS transactions_status
  FROM bai_api_audit_log l
  CROSS JOIN range r
  CROSS JOIN params p
  WHERE l.closingdate BETWEEN r.start_date AND r.end_date
    AND l.endpoint IN ('balances','transactions')
    AND (
      (SELECT cardinality(p.ibans)) = 0
      OR l.iban IN (SELECT unnest(p.ibans))
    )
  GROUP BY l.closingdate::date, l.iban
),
-- ClosingBooked per dag (D)
daily_closing AS (
  SELECT
    b.iban,
    b.reference_date::date AS day,
    b.currency,
    b.amount               AS closing_balance,
    b.audit_id             AS closing_audit_id
  FROM bai_rabobank_balances b
  CROSS JOIN range r
  CROSS JOIN params p
  WHERE b.balance_type = 'closingBooked'
    AND b.reference_date BETWEEN r.start_date AND r.end_date
    AND (
      (SELECT cardinality(p.ibans)) = 0
      OR b.iban IN (SELECT unnest(p.ibans))
    )
),
-- Opening = ClosingBooked van D-1
daily_opening AS (
  SELECT
    b.iban,
    (b.reference_date::date + INTERVAL '1 day')::date AS day,
    b.currency,
    b.amount               AS opening_balance,
    b.audit_id             AS opening_audit_id
  FROM bai_rabobank_balances b
  CROSS JOIN range r
  CROSS JOIN params p
  WHERE b.balance_type = 'closingBooked'
    AND b.reference_date BETWEEN r.start_date - INTERVAL '1 day' AND r.end_date - INTERVAL '1 day'
    AND (
      (SELECT cardinality(p.ibans)) = 0
      OR b.iban IN (SELECT unnest(p.ibans))
    )
),
-- Transactions per dag (incl. audit_id op regelniveau + pos/neg aggregaties)
numeric_transactions AS (
  SELECT
    t.iban,
    DATE(t.rabo_booking_datetime AT TIME ZONE 'Europe/Amsterdam') AS booking_date,
    t.currency,
    t.audit_id AS tx_audit_id,
    (t.rabo_booking_datetime AT TIME ZONE 'Europe/Amsterdam') AS tx_book_dt_local,
    CASE
      WHEN t.transaction_amount IS NULL THEN 0::numeric
      WHEN replace(t.transaction_amount::text, '"', '') ~ '^[+-]?[0-9]+(\.[0-9]+)?$'
        THEN (replace(t.transaction_amount::text, '"', ''))::numeric
      WHEN replace(t.transaction_amount::text, '"', '') ~ '^[+-]?[0-9]+(,[0-9]+)?$'
        THEN replace(replace(t.transaction_amount::text, '"', ''), ',', '.')::numeric
      WHEN replace(t.transaction_amount::text, '"', '') ~ '^[+-]?[0-9]{1,3}(\.[0-9]{3})+,[0-9]{2}$'
        THEN replace(replace(replace(t.transaction_amount::text, '"', ''), '.', ''), ',', '.')::numeric
      WHEN replace(t.transaction_amount::text, '"', '') ~ '^[+-]?[0-9]{1,3}(,[0-9]{3})+\.[0-9]{2}$'
        THEN replace(replace(t.transaction_amount::text, '"', ''), ',', '')::numeric
      ELSE 0::numeric
    END AS amount_numeric
  FROM bai_rabobank_transactions t
  CROSS JOIN range r
  CROSS JOIN params p
  WHERE (
      (SELECT cardinality(p.ibans)) = 0
      OR t.iban IN (SELECT unnest(p.ibans))
    )
    AND DATE(t.rabo_booking_datetime AT TIME ZONE 'Europe/Amsterdam')
        BETWEEN r.start_date AND r.end_date
),
daily_transactions AS (
  SELECT
    iban,
    booking_date,
    COUNT(*)                                      AS transaction_count,
    SUM(amount_numeric)                           AS total_transactions,
    -- positief
    COUNT(*) FILTER (WHERE amount_numeric > 0)    AS pos_tx_count,
    SUM(CASE WHEN amount_numeric > 0 THEN amount_numeric ELSE 0 END) AS pos_tx_sum,
    -- negatief
    COUNT(*) FILTER (WHERE amount_numeric < 0)    AS neg_tx_count,
    SUM(CASE WHEN amount_numeric < 0 THEN amount_numeric ELSE 0 END) AS neg_tx_sum,
    MAX(currency)                                 AS currency,
    array_agg(DISTINCT tx_audit_id)               AS tx_audit_ids,                  -- alle audit_ids (distinct)
    (array_agg(tx_audit_id ORDER BY tx_book_dt_local DESC))[1] AS last_tx_audit_id  -- laatste audit_id (op lokale boekingstijd)
  FROM numeric_transactions
  GROUP BY iban, booking_date
)
-- Eindresultaat
SELECT
  i.iban,
  COALESCE(ai.owner_name, '')                              AS owner_name,
  r.day,
  CASE
    WHEN o.opening_balance IS NULL THEN 'MISSING_OPENING'
    WHEN c.closing_balance IS NULL THEN 'MISSING_CLOSING'
    WHEN ABS(COALESCE(c.closing_balance, 0) - (COALESCE(o.opening_balance, 0) + COALESCE(dt.total_transactions, 0))) < 0.01 THEN 'PERFECT_MATCH'
    WHEN ABS(COALESCE(c.closing_balance, 0) - (COALESCE(o.opening_balance, 0) + COALESCE(dt.total_transactions, 0))) < 1.00 THEN 'MINOR_DIFF'
    ELSE 'MAJOR_DIFF'
  END                                                      AS audit_status,
  COALESCE(a.balances_status, 'MISSING')                  AS balances_status,
  COALESCE(a.transactions_status, 'MISSING')              AS transactions_status,
  COALESCE(c.currency, o.currency, dt.currency, '')       AS currency,
  CASE WHEN o.opening_balance IS NOT NULL THEN 'YES' ELSE 'MISSING' END AS has_opening,
  CASE WHEN c.closing_balance IS NOT NULL THEN 'YES' ELSE 'MISSING' END AS has_closing,
  CASE WHEN COALESCE(dt.transaction_count, 0) > 0 THEN 'YES' ELSE 'NO_TX' END AS has_transactions,

  COALESCE(o.opening_balance, 0)::numeric(18,2)           AS opening_balance,
  COALESCE(dt.total_transactions, 0)::numeric(18,2)       AS sum_transactions,
  COALESCE(dt.transaction_count, 0)::int                  AS transaction_count,
  COALESCE(dt.pos_tx_sum, 0)::numeric(18,2)               AS pos_tx_sum,
  COALESCE(dt.pos_tx_count, 0)::int                       AS pos_tx_count,
  COALESCE(dt.neg_tx_sum, 0)::numeric(18,2)               AS neg_tx_sum,
  COALESCE(dt.neg_tx_count, 0)::int                       AS neg_tx_count,
  COALESCE(c.closing_balance, 0)::numeric(18,2)           AS closing_balance,

  ROUND(COALESCE(o.opening_balance, 0) + COALESCE(dt.total_transactions, 0), 2) AS expected_closing,
  ROUND(COALESCE(c.closing_balance, 0) - (COALESCE(o.opening_balance, 0) + COALESCE(dt.total_transactions, 0)), 2) AS difference,

  COALESCE(o.opening_audit_id::text, '')                  AS opening_audit_id,
  COALESCE(c.closing_audit_id::text, '')                  AS closing_audit_id,
  COALESCE(dt.last_tx_audit_id::text, '')                 AS last_tx_audit_id,
  COALESCE(array_to_string(dt.tx_audit_ids, ','), '')     AS tx_audit_ids_csv
FROM ib_all i
CROSS JOIN rng r
LEFT JOIN audit_pivot a  ON a.day = r.day AND a.iban = i.iban
LEFT JOIN daily_opening o ON o.iban = i.iban AND o.day = r.day
LEFT JOIN daily_closing c ON c.iban = i.iban AND c.day = r.day
LEFT JOIN daily_transactions dt ON dt.iban = i.iban AND dt.booking_date = r.day
LEFT JOIN bai_rabobank_account_info ai ON ai.iban = i.iban
ORDER BY i.iban, r.day DESC;