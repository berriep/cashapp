<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rabobank BAI PostgreSQL Schema - Technical Specification</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #fff;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
            margin-top: 40px;
            margin-bottom: 20px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        h4 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 12px;
        }
        code {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.9em;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }
        pre code {
            background: none;
            border: none;
            padding: 0;
            font-size: 0.85em;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            font-size: 0.9em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .highlight {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .info-box {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 15px 0;
        }
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        strong {
            color: #2c3e50;
        }
        .page-break {
            page-break-before: always;
        }
        @media print {
            body {
                max-width: none;
                margin: 0;
                padding: 15px;
            }
            h1, h2 {
                break-after: avoid;
            }
            pre, table {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>

<h1>Technical Approach for Rabobank Business Account Insight (BAI)</h1>

<p>This documentation describes the technical implementation for storing <strong>Business Account Insight (BAI)</strong> data in <strong>PostgreSQL</strong>, with full traceability via an externally generated <code>audit_id</code> (from RPA UiPath). BAI encompasses both <strong>balances</strong> and <strong>transactions</strong> data from Rabobank APIs. Each balance API call contains multiple balanceTypes (such as <code>interimBooked</code>, <code>expected</code>, <code>closingBooked</code>), and each transaction API call contains multiple transaction records, all stored separately with full audit traceability. The structure supports <strong>retries</strong> via an additional <code>attempt_nr</code> column, allowing repeated API calls under the same <code>audit_id</code> to be registered.</p>

<h2>Why External audit_id?</h2>

<p>The choice for an <strong>externally generated audit_id</strong> (instead of database auto-generated IDs) serves a critical business requirement: <strong>direct traceability between input files and database records</strong>.</p>

<div class="info-box">
<h4>Business Context:</h4>
<ul>
<li>UiPath RPA process downloads API responses and saves them as JSON files</li>
<li>These input files are named using the <code>audit_id</code>: <code>transactions_{audit_id}.json</code>, <code>balances_{audit_id}.json</code></li>
<li>When processing these files into the database, the same <code>audit_id</code> is used as the primary linking key</li>
<li>This creates <strong>1:1 traceability</strong>: any database record can be traced back to its exact source file</li>
<li><strong>Debugging advantage</strong>: when data issues arise, developers can immediately locate the original API response file</li>
<li><strong>Audit compliance</strong>: complete data lineage from API call → file storage → database storage</li>
</ul>
</div>

<div class="info-box">
<h4>Technical Implementation:</h4>
<ul>
<li>UiPath generates UUID <code>audit_id</code> before API call</li>
<li>API response is saved as <code>{endpoint}_{audit_id}.json</code></li>
<li>Database records use the same <code>audit_id</code> as foreign key</li>
<li>Result: seamless traceability across the entire data pipeline</li>
</ul>
</div>

<hr class="page-break">

<h2>1. Audit Log Table</h2>

<p>The audit table records metadata for each API call, including status, duration, and origin. Retries are supported via <code>attempt_nr</code>, allowing the same <code>audit_id</code> to occur multiple times without conflict.</p>

<pre><code>CREATE TABLE IF NOT EXISTS rpa_data.bai_api_audit_log (
    id UUID NOT NULL,                      -- externally generated audit_id (e.g., UiPath)
    attempt_nr SMALLINT NOT NULL DEFAULT 1, -- retry counter, starts at 1
    timestamp TIMESTAMPTZ NOT NULL DEFAULT now(),
    bank CHARACTER VARYING(50) NOT NULL,
    endpoint CHARACTER VARYING(255) NOT NULL,        -- e.g., /balances
    http_method CHARACTER VARYING(10),
    response_status INTEGER,
    response_time_ms INTEGER,
    caller_id CHARACTER VARYING(100),
    correlation_id UUID,
    error_message TEXT,
    closingdate DATE,                      -- closing date for the API call
    iban CHARACTER VARYING(34),                          -- IBAN for the API call
    CONSTRAINT bai_api_audit_log_pkey PRIMARY KEY (id, attempt_nr)
);

-- Indexes for performance analysis and quick lookup
CREATE INDEX IF NOT EXISTS idx_bai_audit_bank_endpoint_ts ON rpa_data.bai_api_audit_log (bank, endpoint, timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_bai_audit_status ON rpa_data.bai_api_audit_log (response_status);
CREATE INDEX IF NOT EXISTS idx_bai_audit_correlation ON rpa_data.bai_api_audit_log (correlation_id);</code></pre>

<hr class="page-break">

<h2>2. Rabobank Balance Table</h2>

<p>Each <code>balanceType</code> from the payload is stored as a separate row and linked to the <code>audit_id</code> and <code>attempt_nr</code> of the API call.</p>

<pre><code>CREATE TABLE IF NOT EXISTS rpa_data.bai_rabobank_balances (
    id UUID NOT NULL DEFAULT gen_random_uuid(),
    audit_id UUID NOT NULL,
    attempt_nr SMALLINT DEFAULT 1,
    iban CHARACTER VARYING(34) NOT NULL,
    currency CHARACTER VARYING(3) NOT NULL,
    balance_type CHARACTER VARYING(50) NOT NULL,
    amount NUMERIC(18,2) NOT NULL,
    reference_date DATE,                 -- only present for closingBooked
    last_change_datetime TIMESTAMPTZ,    -- present for interimBooked and expected
    retrieved_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT bai_rabobank_balances_pkey PRIMARY KEY (id),
    CONSTRAINT bai_rabobank_balances_audit_id_attempt_nr_fkey FOREIGN KEY (audit_id, attempt_nr)
        REFERENCES rpa_data.bai_api_audit_log (id, attempt_nr) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT bai_rabobank_balances_balance_type_check CHECK (balance_type::text = ANY (ARRAY['interimBooked'::character varying, 'expected'::character varying, 'closingBooked'::character varying]::text[]))
);

-- Indexes for fast selection and filtering
CREATE INDEX IF NOT EXISTS idx_bai_balance_iban_type_date
    ON rpa_data.bai_rabobank_balances USING btree
    (iban, balance_type, reference_date);

CREATE INDEX IF NOT EXISTS idx_bai_balance_audit_id_attempt
    ON rpa_data.bai_rabobank_balances USING btree
    (audit_id, attempt_nr);

CREATE INDEX IF NOT EXISTS idx_bai_balance_retrieved_at
    ON rpa_data.bai_rabobank_balances USING btree
    (retrieved_at DESC);</code></pre>

<hr class="page-break">

<h2>3. Rabobank Transactions Table</h2>

<p>Each transaction from the API response is stored as a separate row and linked to the <code>audit_id</code> and <code>attempt_nr</code> of the API call. The structure contains all relevant fields from the Rabobank Transactions API, including debtor/creditor information, amounts, and Rabobank-specific metadata.</p>

<div class="highlight">
<h4>Field Notes:</h4>
<ul>
<li><strong>Mandatory (NOT NULL)</strong>: fields that are always present in every transaction</li>
<li><strong>Optional</strong>: fields that can be NULL depending on transaction type or direction</li>
<li><strong>Direction-dependent</strong>: <code>debtor_*</code> fields are only populated for <strong>incoming</strong> payments, <code>creditor_*</code> for <strong>outgoing</strong> payments</li>
<li><strong>SEPA-specific</strong>: <code>creditor_id</code>, <code>mandate_id</code> are only present for SEPA direct debit transactions</li>
<li><strong>Currency-specific</strong>: <code>currency_exchange_*</code> and <code>instructed_amount_*</code> are only present for multi-currency transactions</li>
</ul>
</div>

<pre><code>CREATE TABLE IF NOT EXISTS rpa_data.bai_rabobank_transactions (
    id UUID NOT NULL DEFAULT gen_random_uuid(),
    audit_id UUID NOT NULL,
    attempt_nr SMALLINT DEFAULT 1,
    
    -- Account information (always present)
    iban CHARACTER VARYING(34) NOT NULL,                    -- Own account (from account.iban)
    currency CHARACTER VARYING(3) NOT NULL,                 -- Account currency
    
    -- Transaction basic data (mandatory)
    booking_date DATE NOT NULL,                   -- Date transaction was booked
    entry_reference CHARACTER VARYING(35) NOT NULL,         -- Unique bank reference (UNIQUE candidate)
    transaction_amount NUMERIC(18,2) NOT NULL,    -- Transaction amount (transactionAmount.value)
    transaction_currency CHARACTER VARYING(3) NOT NULL,     -- Transaction currency
    bank_transaction_code CHARACTER VARYING(50) NOT NULL,   -- Bank transaction code (e.g., PMNT-RCDT-ESCT)
    
    -- Transaction optional basic data
    value_date DATE,                              -- Value date (usually = booking_date)
    interbank_settlement_date DATE,               -- Settlement between banks (optional)
    end_to_end_id CHARACTER VARYING(35),                    -- End-to-end identification (often present)
    batch_entry_reference CHARACTER VARYING(35),            -- Batch reference (rarely used)
    acctsvcr_ref CHARACTER VARYING(35),                     -- Account Servicer Reference (strongest unique ref)
    instruction_id CHARACTER VARYING(35),                   -- Instruction reference
    
    -- Debtor (payer) information — ONLY for INCOMING payments
    debtor_iban CHARACTER VARYING(34),                      -- Payer's IBAN (NULL for outgoing)
    debtor_name CHARACTER VARYING(140),                     -- Payer's name
    debtor_agent_bic CHARACTER VARYING(11),                 -- Payer's BIC (debtorAgent from BAI JSON)
    
    -- Creditor (payee) information — ONLY for OUTGOING payments  
    creditor_iban CHARACTER VARYING(34),                    -- Payee's IBAN (NULL for incoming)
    creditor_name CHARACTER VARYING(140),                   -- Payee's name
    creditor_agent_bic CHARACTER VARYING(11),               -- Payee's BIC (creditorAgent from BAI JSON)
    creditor_currency CHARACTER VARYING(3),                 -- Currency of creditor account (usually EUR)
    creditor_id CHARACTER VARYING(35),                      -- SEPA Creditor ID (only for direct debit)
    
    -- Ultimate parties (optional — mainly for batch/corporate payments)
    ultimate_debtor CHARACTER VARYING(140),                 -- Ultimate debtor name
    ultimate_creditor CHARACTER VARYING(140),               -- Ultimate creditor name
    initiating_party_name CHARACTER VARYING(140),           -- Initiating party name
    
    -- SEPA Direct Debit specific
    mandate_id CHARACTER VARYING(35),                       -- SEPA mandate ID (only for direct debit)
    
    -- Payment information (usually present)
    remittance_information_unstructured CHARACTER VARYING(140),  -- Free text description
    remittance_information_structured CHARACTER VARYING(140),    -- Structured payment reference (e.g., ISO payment ref)
    purpose_code CHARACTER VARYING(4),                      -- Purpose code (e.g., EPAY, SALA, PENS)
    reason_code CHARACTER VARYING(4),                       -- Reason code (e.g., AG01 for return payments)
    
    -- Batch information (optional)
    payment_information_identification CHARACTER VARYING(35),  -- Payment Information ID
    number_of_transactions INTEGER,                   -- Number of transactions in batch
    
    -- Multi-currency exchange information (only for FX transactions)
    currency_exchange_rate NUMERIC(12,6),         -- Exchange rate
    currency_exchange_source_currency CHARACTER VARYING(3), -- Source currency
    currency_exchange_target_currency CHARACTER VARYING(3), -- Target currency
    instructed_amount NUMERIC(18,2),              -- Original amount (before conversion)
    instructed_amount_currency CHARACTER VARYING(3),        -- Currency of original amount
    
    -- Rabobank specific fields (mandatory)
    rabo_booking_datetime TIMESTAMPTZ NOT NULL,   -- Exact booking timestamp from Rabobank
    rabo_detailed_transaction_type CHARACTER VARYING(10) NOT NULL,  -- Rabobank transaction type code
    rabo_transaction_type_name CHARACTER VARYING(50),       -- Rabobank transaction type name (usually present)
    
    -- Balance after transaction (optional — not always present)
    balance_after_booking_amount NUMERIC(18,2),   -- Balance after booking
    balance_after_booking_currency CHARACTER VARYING(3),    -- Currency of balance (usually EUR)
    balance_after_booking_type CHARACTER VARYING(50),       -- Balance type (e.g., InterimBooked)
    
    -- Metadata
    source_system CHARACTER VARYING(20) DEFAULT 'BAI_API'::CHARACTER VARYING,  -- Source system ('CAMT053', 'BAI_API')
    created_at TIMESTAMPTZ DEFAULT now(),         -- Timestamp of storage in DB
    updated_at TIMESTAMPTZ DEFAULT now(),         -- Last modification timestamp
    retrieved_at TIMESTAMPTZ DEFAULT now(),        -- When data was retrieved
    
    CONSTRAINT bai_rabobank_transactions_pkey PRIMARY KEY (id),
    CONSTRAINT bai_rabobank_transactions_audit_id_attempt_nr_fkey FOREIGN KEY (audit_id, attempt_nr)
        REFERENCES rpa_data.bai_api_audit_log (id, attempt_nr) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
);</code></pre>

<hr class="page-break">

<h2>4. Rabobank Account Information Table</h2>

<p>This table stores basic account information for Rabobank accounts, including IBAN, owner name, and account status. This is used as a reference table for account metadata.</p>

<pre><code>CREATE TABLE IF NOT EXISTS rpa_data.bai_rabobank_account_info (
    id INTEGER NOT NULL DEFAULT nextval('bai_rabobank_account_info_id_seq'::regclass),
    iban CHARACTER VARYING(34) NOT NULL,
    owner_name CHARACTER VARYING(255) NOT NULL,
    currency CHARACTER VARYING(3) NOT NULL DEFAULT 'EUR'::CHARACTER VARYING,
    resource_id CHARACTER VARYING(255),
    status CHARACTER VARYING(20) DEFAULT 'enabled'::CHARACTER VARYING,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    CONSTRAINT bai_rabobank_account_info_pkey PRIMARY KEY (id),
    CONSTRAINT bai_rabobank_account_info_iban_key UNIQUE (iban)
);</code></pre>

<hr class="page-break">

<h2>5. Recommendations and Extensions</h2>

<table>
<thead>
<tr>
<th>Component</th>
<th>Recommendation</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Retries</strong></td>
<td>Use <code>attempt_nr</code> to make repeated API calls unique and fully traceable.</td>
</tr>
<tr>
<td><strong>Other tables</strong></td>
<td>Add <code>(audit_id, attempt_nr)</code> as FK to <code>bai_api_audit_log</code> in all tables.</td>
</tr>
<tr>
<td><strong>Timezones</strong></td>
<td>Use <code>TIMESTAMPTZ</code> for correct handling of UTC times from the API.</td>
</tr>
<tr>
<td><strong>Data consistency</strong></td>
<td>Use <code>CHECK</code> constraint for allowed balanceTypes and validate critical fields (IBAN, amounts).</td>
</tr>
<tr>
<td><strong>Indexing</strong></td>
<td><strong>Balances:</strong> <code>(iban, balance_type, reference_date)</code> and <code>(audit_id, attempt_nr)</code><br><strong>Transactions:</strong> <code>(iban, booking_date)</code>, <code>(entry_reference)</code>, <code>(debtor_iban)</code>, <code>(creditor_iban)</code>, <code>(end_to_end_id)</code>, <code>(mandate_id)</code></td>
</tr>
<tr>
<td><strong>Archiving</strong></td>
<td><strong>Annual</strong> archiving for low-frequency environments with 480K transactions/year.</td>
</tr>
<tr>
<td><strong>Performance</strong></td>
<td>Low query frequency: archive transactions older than <strong>3 years</strong> to maintain long-term reporting capabilities.</td>
</tr>
<tr>
<td><strong>Low Volume Strategy</strong></td>
<td>For 480K/year with infrequent queries: 3-year production retention, annual archiving, quarterly monitoring, maintains multi-year reporting.</td>
</tr>
</tbody>
</table>

<hr class="page-break">

<h2>6. Archiving Strategy</h2>

<h3>6.1 Why Archive?</h3>

<p><strong>Transactions table grows rapidly:</strong></p>
<ul>
<li>28 accounts with in total 40.000 transactions per month</li>
<li>480.000 transactions per year</li>
</ul>

<p><strong>Performance degradation:</strong></p>
<ul>
<li>Indexes become larger and slower</li>
<li>Queries over large datasets take longer</li>
<li>Backup/restore time increases</li>
</ul>

<h3>6.2 Recommended Archiving Strategy</h3>

<h4>Option A: Separate Archive Table (Recommended)</h4>

<p><strong>Advantages:</strong></p>
<ul>
<li>Production data remains small and fast</li>
<li>Archive remains available for reporting</li>
<li>Easy to restore if needed</li>
</ul>

<pre><code>-- Archive table for transactions (identical structure)
CREATE TABLE IF NOT EXISTS rpa_data.bai_rabobank_transactions_archive (
    LIKE rpa_data.bai_rabobank_transactions INCLUDING ALL
);

-- Annual archiving: move data older than 3 years
INSERT INTO rpa_data.bai_rabobank_transactions_archive
SELECT * FROM rpa_data.bai_rabobank_transactions
WHERE booking_date < CURRENT_DATE - INTERVAL '3 years';

-- Delete archived data from production table
DELETE FROM rpa_data.bai_rabobank_transactions
WHERE booking_date < CURRENT_DATE - INTERVAL '3 years';</code></pre>

<h3>6.3 Retention Periods (Legal)</h3>

<p><strong>Netherlands (Fiscal):</strong></p>
<ul>
<li><strong>Minimum 7 years</strong> for fiscal administration (Dutch Bookkeeping Records Retention Act)</li>
<li><strong>Bank transactions:</strong> retention requirement starts January 1st after end of fiscal year</li>
<li><strong>Recommendation:</strong>
<ul>
<li>Production data: <strong>3 years</strong> (fast access, supports multi-year reporting)</li>
<li>Archive data: <strong>4 years</strong> (online available)</li>
<li>Cold storage: <strong>7+ years</strong> (tape/cloud backup)</li>
</ul>
</li>
</ul>

<table>
<thead>
<tr>
<th>Period</th>
<th>Storage</th>
<th>Availability</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>0-3 years</td>
<td>Production DB</td>
<td>Immediate (&lt; 1s)</td>
<td>Active queries, multi-year reporting</td>
</tr>
<tr>
<td>3-7 years</td>
<td>Archive DB</td>
<td>Fast (&lt; 10s)</td>
<td>Historical reporting, audits</td>
</tr>
<tr>
<td>7+ years</td>
<td>Cold storage / tape</td>
<td>Very slow (days)</td>
<td>Compliance</td>
</tr>
</tbody>
</table>

<hr class="page-break">

<h2>7. Summary</h2>

<p><strong>Result:</strong> This final setup provides a scalable, audit-proof, and performant structure for storing and analyzing Rabobank <strong>balance and transactions payloads</strong>, including retry support within an RPA/UiPath-driven environment. All data is traceable via <code>audit_id</code> and <code>attempt_nr</code> back to the original API call.</p>

<div class="info-box">
<h4>Key Benefits:</h4>
<ul>
<li><strong>Full Traceability:</strong> Every database record can be traced back to original API response files</li>
<li><strong>Retry Support:</strong> Handles API retry scenarios without data conflicts</li>
<li><strong>Performance Optimized:</strong> Proper indexing and archiving strategy for 480K transactions/year</li>
<li><strong>Audit Compliant:</strong> Meets Dutch 7-year retention requirements</li>
<li><strong>Scalable Architecture:</strong> Supports both current volumes and future growth</li>
</ul>
</div>

</body>
</html>